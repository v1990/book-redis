# 原理与实现


## 单线程架构

一条命令到达服务端之后不会立刻被执行，
所有命令都会进入一个队列中，
然后逐个被执行。

redis单线程原因：

1. 纯内存访问

2. 非阻塞IO，使用epoll作为IO多路复用模型，加上redis自身的事件处理模型将epoll中的连接/读写/关闭都转换为事件，不在网络IO上浪费过多的时间

3. 单线程避免了**线程切换**和**竟态**产生的消耗

单线程问题：

1. 对于每个命令的执行时间有要求，如果一个命令执行时间过长，会造成其他命令的阻塞
所以redis是面向快速执行场景的数据库


## 事件驱动

redis 内部有一个小型的事件驱动，它和 libevent 网络库的事件驱动一样，
都是依托操作系统的 I/O 多路复用技术支撑起来的，
这种 IO 驱动模型有个经典的名字：Reactor 模型，反应炉。

利用 I/O 多路复用技术，监听感兴趣的 I/O 事件，例如读事件，写事件等，
同时也要维护一个以文件描述符为主键，数据为某个预设函数的事件表，这里其实就是一个数组或者链表 。
当事件触发时，比如某个文件描述符可读，系统会返回文件描述符值，用这个值在事件表中找到相应的数据项（包括回调函数等），从而实现回调。
同样的，定时事件也是可以实现的，因为系统提供的 I/O 多路复用技术中的函数允许我们设置等待超时的时间，预设定时间内没有事件发生时，会返回。

![事件循环模型](http://daoluan.net/redis-source-notes/assets/event-model-2.png)

redis 的事件驱动总结如下：

- 初始化事件循环结构体
- 注册监听套接字的读事件
- 注册定时事件
- 进入事件循环
- 如果监听套接字变为可读，会接收客户端请求，并为对应的套接字注册读事件
- 如果与客户端连接的套接字变为可读，执行相应的操作